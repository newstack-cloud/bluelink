name: Release Please

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs: {}

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      paths_released: ${{ steps.release.outputs.paths_released }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  # Post-process tags for Go module compatibility
  fix-go-tags:
    needs: release-please
    if: ${{ needs.release-please.outputs.releases_created == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v6
        with:
          go-version: '1.24'

      - name: Create Go module tags
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Map component names to paths
          declare -A COMPONENT_TO_PATH=(
            ["cli"]="apps/cli"
            ["deploy-engine"]="apps/deploy-engine"
            ["blueprint"]="libs/blueprint"
            ["blueprint-resolvers"]="libs/blueprint-resolvers"
            ["blueprint-state"]="libs/blueprint-state"
            ["common"]="libs/common"
            ["deploy-engine-client"]="libs/deploy-engine-client"
            ["plugin-framework"]="libs/plugin-framework"
            ["blueprint-ls"]="tools/blueprint-ls"
            ["plugin-docgen"]="tools/plugin-docgen"
            ["bluelink-manager"]="tools/bluelink-manager"
          )

          # Get newly created tags from release-please
          for tag in $(git tag --points-at HEAD); do
            # Extract component and version (format: component/vX.Y.Z)
            if [[ "$tag" =~ ^([^/]+)/(.+)$ ]]; then
              component="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"

              if [[ -n "${COMPONENT_TO_PATH[$component]}" ]]; then
                path="${COMPONENT_TO_PATH[$component]}"
                new_tag="${path}/${version}"

                if [[ "$tag" != "$new_tag" ]]; then
                  echo "Creating Go module tag: $new_tag (from $tag)"
                  git tag "$new_tag" HEAD
                  git push origin "$new_tag"

                  # Associate the new tag with the existing release
                  echo "Associating $new_tag with release $tag"
                  gh release edit "$tag" --tag "$new_tag"

                  # Trigger component release workflow if it exists
                  workflow_file="${component}-release.yml"
                  if gh workflow view "$workflow_file" &>/dev/null; then
                    echo "Triggering $workflow_file for tag: $new_tag"
                    gh workflow run "$workflow_file" -f tag="$new_tag"
                  fi

                  # Index Go library modules with the Go proxy
                  if [[ "$path" == libs/* ]]; then
                    MODULE="github.com/${{ github.repository }}/${path}"
                    echo "Indexing Go module: ${MODULE}@${version}"
                    GOPROXY=proxy.golang.org go list -m "${MODULE}@${version}" || echo "Warning: Failed to index ${MODULE}@${version}"
                  fi
                fi
              fi
            fi
          done
